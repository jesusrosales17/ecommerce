// Código para adaptar Excel a CSV
// Hacer que ambas funciones creen la misma estructura

import { jsPDF } from 'jspdf';
import autoTable from 'jspdf-autotable';
import * as XLSX from 'xlsx';

// Interfaces y otras definiciones permanecen igual...
export interface ExportData {
  overview: {
    totalUsers: number;
    totalProducts: number;
    totalCategories: number;
    totalOrders: number;
    pendingOrders: number;
    totalRevenue: number;
    userGrowthPercentage: number;
  };
  recentOrders: Array<{
    id: string;
    total: number;
    status: string;
    createdAt: string;
    customerName: string;
    customerEmail: string;
    itemsCount: number;
  }>;
  topProducts: Array<{
    id: string;
    name: string;
    price: number;
    category: { name: string };
    totalSold: number;
  }>;
  lowStockProducts: Array<{
    id: string;
    name: string;
    stock: number;
    category: { name: string } | null;
  }>;
  monthlyStats: Array<{
    month: string;
    orders: number;
    revenue: number;
  }>;
}

// Interface para datos de reportes específicos
export interface ReportData {
  quickStats?: {
    totalRevenue: number;
    totalOrders: number;
    totalUsers: number;
    totalProducts: number;
    revenueChange: string;
    ordersChange: string;
    usersChange: string;
    productsChange: string;
    revenueTrend: 'up' | 'down';
    ordersTrend: 'up' | 'down';
    usersTrend: 'up' | 'down';
    productsTrend: 'up' | 'down';
  };
  topProducts?: Array<{
    id: string;
    name: string;
    price: number;
    category: { name: string } | null;
    totalSold: number;
  }>;
  recentReports?: Array<{
    name: string;
    type: string;
    date: string;
    status: string;
  }>;
  monthlyStats?: Array<{
    month: string;
    orders: number;
    revenue: number;
  }>;
  orderStatusData?: Array<{
    status: string;
    count: number;
    color: string;
  }>;
  // Para reportes específicos
  summary?: any;
  salesTrends?: any;
  topCustomers?: any;
  categoryAnalysis?: any;
  [key: string]: any;
}

// Las funciones exportToPDF y exportToExcel permanecen igual...
export const exportToPDF = (data: ExportData) => {
  // Implementación existente...
};

export const exportToExcel = async (data: ExportData, dateRange: string, reportId?: string) => {
  // Implementación existente...
};

// Nueva función para generar PDF como Buffer para reportes específicos
export const generatePDFReport = async (data: ReportData, dateRange: string, reportId?: string): Promise<Buffer> => {
  // Los datos ya vienen completos del endpoint, no necesitamos volver a buscarlos
  const completeData = data;

  const doc = new jsPDF();
  
  // Título del documento
  doc.setFontSize(20);
  const title = reportId ? getReportTitle(reportId) : 'Reporte General';
  doc.text(title, 14, 22);
  
  // Fecha del reporte
  doc.setFontSize(12);
  doc.text(`Período: ${formatDateRangeText(dateRange)}`, 14, 32);
  doc.text(`Generado: ${new Date().toLocaleDateString('es-ES')}`, 14, 42);
  
  let currentY = 55;  
  // Generar contenido específico según el tipo de reporte
  if (reportId && completeData) {
    switch (reportId) {
      case 'sales-summary':
        currentY = await addSalesSummaryContent(doc, completeData, currentY);
        break;
      case 'customer-analysis':
        currentY = await addCustomerAnalysisContent(doc, completeData, currentY);
        break;
      case 'product-performance':
        currentY = await addProductPerformanceContent(doc, completeData, currentY);
        break;
      case 'financial-report':
        currentY = await addFinancialReportContent(doc, completeData, currentY);
        break;
      case 'orders-analysis':
        currentY = await addOrdersAnalysisContent(doc, completeData, currentY);
        break;
      default:
        // Fallback para reportes generales
        currentY = await addGeneralReportContent(doc, completeData, currentY);
        break;
    }
  } else {
    // Fallback para reportes sin tipo específico
    currentY = await addGeneralReportContent(doc, completeData, currentY);
  }
  
  // Convertir a Buffer
  const pdfBuffer = Buffer.from(doc.output('arraybuffer'));
  return pdfBuffer;
};

// Nueva función para generar Excel como Buffer
export const generateExcelReport = async (data: ReportData, dateRange: string, reportId?: string): Promise<Buffer> => {
  // Si tenemos reportId, obtener los datos completos del mismo endpoint que usa la vista previa
  let completeData = data;
  if (reportId) {
    try {
      // Usar el mismo endpoint que usa la vista previa para obtener TODOS los datos
      const response = await fetch(`${process.env.NEXTAUTH_URL || 'http://localhost:3000'}/api/admin/reports/${reportId}?dateRange=${dateRange}`);
      if (response.ok) {
        const apiResponse = await response.json();
        completeData = apiResponse.data;
      }
    } catch (error) {
      console.error('Error fetching complete report data for Excel:', error);
      // Si falla, usar los datos originales
    }
  }

  const workbook = XLSX.utils.book_new();
  
  // Generar hojas específicas según el tipo de reporte
  if (reportId && completeData) {
    switch (reportId) {
      case 'sales-summary':
        addSalesSummaryExcelSheets(workbook, completeData);
        break;
      case 'customer-analysis':
        addCustomerAnalysisExcelSheets(workbook, completeData);
        break;
      case 'product-performance':
        addProductPerformanceExcelSheets(workbook, completeData);
        break;
      case 'financial-report':
        addFinancialReportExcelSheets(workbook, completeData);
        break;
      case 'orders-analysis':
        addOrdersAnalysisExcelSheets(workbook, completeData);
        break;
      default:
        addGeneralExcelSheets(workbook, completeData);
        break;
    }
  } else {
    addGeneralExcelSheets(workbook, completeData);
  }
  
  // Convertir a Buffer
  const excelBuffer = XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' });
  return excelBuffer;
};

// Nueva función para generar CSV como Buffer
export const generateCSVReport = async (data: ReportData, dateRange: string, reportId?: string): Promise<Buffer> => {
  // Si tenemos reportId, obtener los datos completos del mismo endpoint que usa la vista previa
  let completeData = data;
  if (reportId) {
    try {
      // Usar el mismo endpoint que usa la vista previa para obtener TODOS los datos
      const response = await fetch(`${process.env.NEXTAUTH_URL || 'http://localhost:3000'}/api/admin/reports/${reportId}?dateRange=${dateRange}`);
      if (response.ok) {
        const apiResponse = await response.json();
        completeData = apiResponse.data;
      }
    } catch (error) {
      console.error('Error fetching complete report data for CSV:', error);
      // Si falla, usar los datos originales
    }
  }

  let csvContent = '';
  
  // Encabezado
  const title = reportId ? getReportTitle(reportId) : 'Reporte General';
  csvContent += `${title}\n`;
  csvContent += `Período: ${formatDateRangeText(dateRange)}\n`;
  csvContent += `Generado: ${new Date().toLocaleDateString('es-ES')}\n\n`;
  
  // Generar contenido específico según el tipo de reporte
  if (reportId && completeData) {
    switch (reportId) {
      case 'sales-summary':
        csvContent += generateSalesSummaryCSV(completeData);
        break;
      case 'customer-analysis':
        csvContent += generateCustomerAnalysisCSV(completeData);
        break;
      case 'product-performance':
        csvContent += generateProductPerformanceCSV(completeData);
        break;
      case 'financial-report':
        csvContent += generateFinancialReportCSV(completeData);
        break;
      case 'orders-analysis':
        csvContent += generateOrdersAnalysisCSV(completeData);
        break;
      default:
        csvContent += generateGeneralCSV(completeData);
        break;
    }
  } else {
    csvContent += generateGeneralCSV(completeData);
  }
  
  return Buffer.from(csvContent, 'utf-8');
};

// Funciones auxiliares
function getReportTitle(reportId: string): string {
  const titles: { [key: string]: string } = {
    'sales-summary': 'Reporte de Resumen de Ventas',
    'customer-analysis': 'Reporte de Análisis de Clientes',
    'product-performance': 'Reporte de Rendimiento de Productos',
    'financial-report': 'Reporte Financiero',
    'orders-analysis': 'Reporte de Análisis de Órdenes',
  };
  return titles[reportId] || 'Reporte Personalizado';
}

function formatDateRangeText(range: string): string {
  const ranges: { [key: string]: string } = {
    '7d': 'Últimos 7 días',
    '30d': 'Últimos 30 días',
    '90d': 'Últimos 90 días',
    '1y': 'Último año'
  };
  return ranges[range] || range;
}

// Resto del código omitido para brevedad...
